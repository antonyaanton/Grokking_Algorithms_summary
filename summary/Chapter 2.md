# Глава 2. Сортировка выбором

## Массивы и списки

При сохранении отдельных значений в памяти компьютера, запрашивается место в памяти, а затем выдается адрес для сохранения значения.

Существует несколько видов хранения списка элементов: **массивы** и **связанные списки**. 

При использовании _массива_ все элементы хранятся в памяти непрерывно, поэтому при добавлении в него новых элементов, компьютер будет должен выделить адрес для такого объема памяти, в который бы уместился массив с добавленным элементом. Элементы _связанного списка_ могут размещаться в памяти где угодно. Так, в каждом элементе _списка_ хранится адрес следующего элемента списка. 

Приемуществом _массива_ перед _связанном списком_ состоит в том, что обращение к любому элементу _массива_ происходит мгновенно. В _связанном списке_ элементы не хранятся рядом друг с другом, поэтому чтобы получить адрес, например, третьего элемента, сначала нужно обратиться к первому элементу, чтобы получить адрес второго, затем ко второму для получения адреса третьего. 

Связанные списки лучше подходят для вставки элемента в середину списка задач. Такая задача решается изменением указателя в предыдущем элементе. Также они эффективно подходят для удаления. 

Использование связанных списков и массивов зависит от сценария использования. Массивы популярны из-за поддержки произвольного доступа. Всего существует два вида доступа: **произвольный** и **последовательный**. При последовательном доступе элементы чиатются по одному, начиная с первого. Его поддерживают только связанные списки. 

## Сортировка выбором

1. Создаем пустой список
2. Проходим по списку и находим элемент с самым наибольшим/наименьшим значением
3. Добавлем элемент в этот список
4. Повторяем

```python
def findSmallest(arr): #функция поиска наименьшего элемента массива
  smallest = arr[0]   #для хранения наименьшего значения
  smallest_index = 0  #для хранения индекса наименьшего значения
  for i in range(1, len(arr)):
    if arr[i] < smallest:
      smallest = arr[i]
      smallest_index = i
    return smallest_index

def selectionSort(arr): #функция сортировки выбором
  newArr = []
  for i in range(len(arr)):
    smallest = findSmallest(arr)
    newArr.append(arr.pop(smallest))
  return newArr
```
## Выводы:

* Память компьютера напоминает огромный шкаф с ящиками.
* Для сохранения набора элементов используют массивы или списки.
* В массиве все элементы хранятся в памяти рядом друг с другом.
* В списке элементы рапределяются в произвольных местах памяти, при этом в одном элементе хранится адрес слеующего элемента.
* Массивы обеспечивают быстрое чтение.
* Списки обеспечивают быструю вставку и удаление.
* Все элементы массива должны быть однотипными (только целые числа, только вещественные числа и т.д.)

