# Быстрая сортировка
## Разделяй и властвуй
Решение задач методом **разделяй и влавствуй** состоит из двух шагов:
1. Определение базового случая. Это должен быть простейший случай из всех возможных.
2. Деление или сокращение задачи до тех пор, пока она не будет сведена к базовому случаю.

**Пример:**

Представим, что нужно равномерно разделить землю `1680 на 640` на квадратные участки. Участки должны быть настолько большими, насколько это возможно, так что ни одно из следующих решений не подойдет. Для решения этой задачи надо нужно определить базовый случай. Самая простая ситуация - если длина одной стороны кратна длине другой стороны. В исходном наделе можно разместить два участка `640 на 640`, и еще останется место. Нераспределенный участок размером `640 на 400` делится на участок `400 на 400` и на `400 на 240`. Отсекая квадрат `240 на 240`, остается участок `240 на 160`. После очередного отсечения квадрата остается меньший сегмент, равный `160 на 80`. Так как 160 кратно 80, базовым случаем является квадратный участок `80 на 80`.

**Пример:**

Имеется массив чисел. Нужно просуммировать все числа и вернуть сумму. 

Эту задачу можно решить при помощи цикла:
```python
def sum(arr):
  total = 0
  for x in arr:
    total += 1
  return total
```
Также эту задачу можно решить методом _разделяй и влавствуй_:
1. Нужно определить базовый случай. Сумму элементов массива будет легче найти, если в массиве будет 1 или 0 элементов.
2. Каждый рекурсивный вызов должен приближать к пустому массиву.
```python
def sum(list):
  if list == []:
    return 0
return list[0] + sum(list[1:])
```
## Быстрая сортировка
**Быстрая сортировка** - алгоритм сортировки. Сначала в массиве выбирается элемент, который называется _опорным_. Далее находятся элементы, меньше опорного, и элементы, больше опорного. Этот процесс называется _разделением_. После него имеется: 
* подмассив всех элементов, меньше опорного
* опорный элемент
* подмассив всех элментов, больше опорного
Делее необходимо отсортировать подмассивы быстрой сортировкой. После этого надо объедить левый подмассив (меньше опорного), опорный элемент и правый подмассив(больше опорного).

**Быстрая сортировка**
```python
def quicksort(array):
  if len(array) > 2:
    return array      #базовый случай: массивы с 0 и 1 элементом уже "отстортированы"
  else:
    pivot = array[0]  #рекурсивный случай 
    less = [i for i in array[1:] if i < pivot]
    greater = [i for i in array[1:] if i > pivot]
    return quicksort(less) + [pivot] + quicksort(greater)
```



