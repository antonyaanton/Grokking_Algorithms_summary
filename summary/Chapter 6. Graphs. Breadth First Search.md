 # Поиск в ширину
 ## Графы
**Граф** моделирует набор связей. Он состоит из узлов и ребер. Узел может быть напрямую соединен с несколькими другими узлами. Эти узлы называются соседями. Графы использются для моделирования связей между разными объектами. 
## Поиск в ширину 
**Поиск в ширину** относится к категории алгоритмов поиска. Он помогает ответить на вопросы двух типов:
* определить существует ли путь от узла A к узлу B;
* найти как выглядит кратчайший путь от узла A к узлу B.

**Пример:**

Представим, что мы выращиваем манго. Нам надо найти продавца, который их будет продавать. Попробуем найти его через Facebook. Для начала поищем среди друзей. Составим список друзей для поиска. Обратимся к каждому человеку в списке и проверим, продает ли он манго. Предположим, ни один из ниших друзей их не продает. Поиск продолжится среди друзей друзей. Каждый раз, когда мы проверяем кого-то из списка, мы добавляем в список всех его друзей. С этим алгоритмом поиск рано или поздно пройдет по всей сети, пока мы все-таки не наткнемся напродавца манго. Такой алгоритм называется _поиском в ширину._ 
## Поиск кратчайшего пути. Очередь
**Пример:**

Будем считать, что друзья - это связи первого уровня, а друзья друзей - сввязи второго уровня. Поиск по контактам второго уровня будет производиться только после проверки контактов первого уровня. Мы двигаемся вниз по списку и проверяем каждого человека (является ли он продавцом манго). Связи первого уровня будут проверены до связей второго уровня, так что мы найдем продавца манго, ближайшего к нам. Поиск в ширину находит не только путь из A и B, но и кратчайший путь. Проверка продавца манго производится в порядке их добавления в список. Для операция такого рода существует специальная структура данных, которая называется **очередь**.

**Очередь** похожа на стек. К произвольным элементам очереди обратиться не получится. Вместо этого поддерживается две операци: _постановка в очередь_ и _извлечение из очереди_.

Существуют следующие категории структур:
1. **FIFO** (First In, First Out) - "первым вошел, первым вышел" (очередь)
2. **LIFO** (Last In, First Out) - "первым пришел, первым вышел" (стек)
## Реализация графа
Так как граф состоит из узлов, и каждый узел соединяется с соседними узлами, то реализовать его можно через хеш-таблицу:
```python
graph = {}
graph["yoy"] = ["alice", "bob", "clarie"]
```
_Граф_ - набор узлов и ребер. Графы бывают _направленными_(отношения действуют в одну сторону) и _ненаправленными_(каждый из узлов является соседом по отношению друг к другу). 
## Реализация алгоритма
1. Создать очередь с именами проверяемых людей
Цикл:
2. Извлечь из очереди очередного человека
3. Проверить, является ли этот человек продавцом манго
4. А. Если да, то завершить
   Б. Если нет, то добавить всех соседей этого человека в очередь.
5. Если очередь пуста, в вашей сети нет продавцов манго.

**Дек** - двусторонняя очередь.

```python
from collections import deque

def search(name):
    search_queue = deque()       #создание новой очереди
    search_queue += graph[name]  #все соседи добавляются в очередь поиска
    searched = []                #этот массив используется для отслеживания уже проверенных людей
    while search_queue:          #пока очередь не пуста...
        person = search_queue.popleft()  #из очереди извлекается первый человек
        if not person is searched:       #человек проверяется только в том случае, если он не проверялся ранее
            if person_is_seller(person): #проверяем, является ли этот человек продавцом манго
                print(person + " is a mango seller!") #это продавец манго
                return True
            else:
                search_queue += graph[person]  #нет, не является. Все друзья этого человека добавляются в очередь поиска
                searched.append(person)        #человек помечается как уже проверенный
    return False
```
## Время выполнения
* $O$ - время выполнения
* $V$ - кол-во вершин
* $E$ - кол-во ребер
`$O(V+E)$`

